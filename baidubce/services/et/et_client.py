# Copyright (c) 2023 Baidu.com, Inc. All Rights Reserved
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions
# and limitations under the License.

"""
This module provides a client class for Et Channel IPv6.
"""

import copy
import json
import uuid

from baidubce import bce_base_client
from baidubce import compat
from baidubce import utils
from baidubce.auth import bce_v1_signer
from baidubce.http import bce_http_client
from baidubce.http import handler
from baidubce.http import http_methods
from baidubce.utils import required


class EtClient(bce_base_client.BceBaseClient):
    """
    Et base sdk client
    """
    prefix = b'/v1'
    et = 'et'
    channel = 'channel'

    def __init__(self, config=None):
        """
        :type config: baidubce.BceClientConfiguration
        """
        bce_base_client.BceBaseClient.__init__(self, config)

    def _merge_config(self, config=None):
        """
        :param config:
        :type config: baidubce.BceClientConfiguration
        :return:
        """
        if config is None:
            return self.config
        else:
            new_config = copy.copy(self.config)
            new_config.merge_non_none_values(config)
            return new_config

    def _send_request(self, http_method, path,
                      body=None, headers=None, params=None,
                      config=None, body_parser=None):
        """
        :param http_method:
        :param path:
        :param body:
        :param headers:
        :param params:
        :param config:
        :param body_parser:
        :return:
        """
        config = self._merge_config(config)
        if body_parser is None:
            body_parser = handler.parse_json
        if headers is None:
            headers = {b'Accept': b'*/*', b'Content-Type':
                b'application/json;charset=utf-8'}

        return bce_http_client.send_request(
            config, bce_v1_signer.sign, [handler.parse_error, body_parser],
            http_method, path, body, headers, params)

    @required(et_id=(bytes, str))
    def get_et_channel(self, et_id, client_token=None, config=None):
        """
        Get et channel.
 
        :param et_id:
            et id
        :type et_id: string

        :param client_token:
            If the clientToken is not specified by the user, a random String
            generated by default algorithm will be used.
        :type client_token: string

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = utils.append_uri(self.prefix, self.et, et_id, self.channel)
        params = {}
        if client_token is None:
            params[b'clientToken'] = generate_client_token()
        else:
            params[b'clientToken'] = client_token

        return self._send_request(http_methods.GET, path, params=params, config=config)
    
    @required(et_id=(bytes, str), et_channel_id=(bytes, str), local_ip=(bytes, str), name=(bytes, str),
              networks=(list, tuple), remote_ip=(bytes, str), route_type=(bytes, str), vlan_id=int)
    def recommit_et_channel(self, et_id, et_channel_id, local_ip, name, networks, remote_ip, route_type, vlan_id,
                            authorized_users=None, description=None, enable_ipv6=None, local_ipv6=None,
                            remote_ipv6=None, ipv6_networks=None, client_token=None, config=None):
        """
        Recommit et channel.
 
        :param et_id:
            et id
        :type et_id: string

        :param et_channel_id:
            et channel id
        :type et_channel_id: string

        :param local_ip:
            baidu IPv4 address of et channel
        :type local_ip: string

        :param name:
            et channel name
        :type name: string

        :param networks:
            et channel IPv4 routes
        :type networks: list<string>

        :param remote_ip:
            customer IPv4 address of et channel
        :type remote_ip: string

        :param route_type:
            et channel route type
        :value "bgp" or "static"
        :type route_type: string

        :param vlan_id:
            et channel vlan id
        :value 0, 2-4009
        :type vlan_id: integer

        :param authorized_users:
            et channel authorized users
        :type authorized_users: list<string>

        :param description:
            et channel description
        :type description: string

        :param enable_ipv6:
            et channel enable ipv6
        :value 0 or 1
        :type enable_ipv6: integer

        :param local_ipv6:
            baidu IPv6 address of et channel
        :type local_ipv6: string

        :param remote_ipv6:
            customer IPv6 address of et channel
        :type remote_ipv6: string

        :param ipv6_networks:
            et channel IPv6 routes
        :type ipv6_networks: list<string>

        :param client_token:
            If the clientToken is not specified by the user, a random String
            generated by default algorithm will be used.
        :type client_token: string

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = utils.append_uri(self.prefix, self.et, et_id, self.channel,
                                et_channel_id)
        params = {b'reCreate':None}
        if client_token is None:
            params[b'clientToken'] = generate_client_token()
        else:
            params[b'clientToken'] = client_token
        
        body = {
            'baiduAddress': local_ip,
            'name': name,
            'networks': networks,
            'customerAddress': remote_ip,
            'routeType': route_type,
            'vlanId': vlan_id,
        }

        if authorized_users is not None:
            body['authorizedUsers'] = authorized_users

        if description is not None:
            body['description'] = compat.convert_to_string(description)

        if enable_ipv6 is not None:
            body['enableIpv6'] = enable_ipv6

        if local_ipv6 is not None:
            body['baiduIpv6Address'] = compat.convert_to_string(local_ipv6)

        if remote_ipv6 is not None:
            body['customerIpv6Address'] = compat.convert_to_string(remote_ipv6)

        if ipv6_networks is not None:
            body['ipv6Networks'] = ipv6_networks

        return self._send_request(http_methods.PUT, path, params=params, body=json.dumps(body), config=config)
    
    @required(et_id=(bytes, str), et_channel_id=(bytes, str))
    def update_et_channel(self, et_id, et_channel_id, name=None, description=None, client_token=None, config=None):
        """
        update et channel.
 
        :param et_id:
            et id
        :type et_id: string

        :param et_channel_id:
            et channel id
        :type et_channel_id: string

        :param name:
            et channel name
        :type name: string

        :param description:
            et channel description
        :type description: string

        :param client_token:
            If the clientToken is not specified by the user, a random String
            generated by default algorithm will be used.
        :type client_token: string

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = utils.append_uri(self.prefix, self.et, et_id, self.channel,
                                et_channel_id)
        params = {b'modifyAttribute': None}
        if client_token is None:
            params[b'clientToken'] = generate_client_token()
        else:
            params[b'clientToken'] = client_token
        
        body = {}

        if name is not None:
            body['name'] = compat.convert_to_string(name)

        if description is not None:
            body['description'] = compat.convert_to_string(description)

        return self._send_request(http_methods.PUT, path, params=params, body=json.dumps(body), config=config)
    
    @required(et_id=(bytes, str), et_channel_id=(bytes, str))
    def delete_et_channel(self, et_id, et_channel_id, client_token=None, config=None):
        """
        Delete et channel.
 
        :param et_id:
            et id
        :type et_id: string

        :param et_channel_id:
            et channel id
        :type et_channel_id: string

        :param client_token:
            If the clientToken is not specified by the user, a random String
            generated by default algorithm will be used.
        :type client_token: string

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = utils.append_uri(self.prefix, self.et, et_id, self.channel,
                                et_channel_id)
        params = {}
        if client_token is None:
            params[b'clientToken'] = generate_client_token()
        else:
            params[b'clientToken'] = client_token

        return self._send_request(http_methods.DELETE, path, params=params, config=config)
    
    @required(et_id=(bytes, str), et_channel_id=(bytes, str),
              local_ipv6=(bytes, str), remote_ipv6=(bytes, str))
    def enable_et_channel_ipv6(self, et_id, et_channel_id, local_ipv6, remote_ipv6,
                               ipv6_networks=None, client_token=None, config=None):
        """
        Enable IPv6 of the specific et channel.
 
        :param et_id:
            et id
        :type et_id: string

        :param et_channel_id:
            et channel id
        :type et_channel_id: string

        :param local_ipv6:
            baidu IPv6 address of et channel
        :type local_ipv6: string

        :param remote_ipv6:
            customer IPv6 address of et channel
        :type remote_ipv6: string

        :param ipv6_networks:
            et channel IPv6 routes
        :type ipv6_networks: list<string>

        :param client_token:
            If the clientToken is not specified by the user, a random String
            generated by default algorithm will be used.
        :type client_token: string

        :param config:
        :type config: baidubce.BceClientConfiguration

        :return:
        :rtype baidubce.bce_response.BceResponse
        """
        path = utils.append_uri(self.prefix, self.et, et_id, self.channel,
                                et_channel_id)
        params = {b'enableIpv6': None}
        if client_token is None:
            params[b'clientToken'] = generate_client_token()
        else:
            params[b'clientToken'] = client_token
        
        body = {
            'baiduIpv6Address': compat.convert_to_string(local_ipv6),
            'customerIpv6Address': compat.convert_to_string(remote_ipv6),
        }

        if ipv6_networks is not None:
            body['ipv6Networks'] = ipv6_networks

        return self._send_request(http_methods.PUT, path, params=params, body=json.dumps(body), config=config)


def generate_client_token_by_uuid():
    """
    The default method to generate the random string for client_token
    if the optional parameter client_token is not specified by the user.

    :return:
    :rtype string
    """
    return str(uuid.uuid4())


generate_client_token = generate_client_token_by_uuid